/**
 * 视频内容提取器
 * 基于 yt-dlp 实现多平台视频信息/字幕/音频提取
 */

const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs');
const path = require('path');
const os = require('os');

const execAsync = promisify(exec);

/**
 * 视频提取器类
 */
class VideoExtractor {
  constructor(options = {}) {
    this.tempDir = options.tempDir || path.join(os.tmpdir(), 'video-extractor');
    this.ytDlpPath = options.ytDlpPath || 'yt-dlp';
    
    // 确保临时目录存在
    if (!fs.existsSync(this.tempDir)) {
      fs.mkdirSync(this.tempDir, { recursive: true });
    }
  }

  /**
   * 获取视频信息
   * @param {string} url - 视频URL
   * @returns {Promise<Object>} 视频信息
   */
  async getInfo(url) {
    try {
      const { stdout } = await execAsync(
        `${this.ytDlpPath} --dump-json --no-download "${url}"`,
        { timeout: 60000 }
      );
      
      const info = JSON.parse(stdout);
      
      return {
        id: info.id,
        title: info.title,
        description: info.description,
        duration: info.duration,
        uploader: info.uploader,
        uploadDate: info.upload_date,
        webpageUrl: info.webpage_url,
        thumbnails: info.thumbnails,
        // 字幕信息
        subtitles: info.subtitles || {},
        automaticCaptions: info.automatic_captions || {},
        // 格式信息
        formats: info.formats?.map(f => ({
          formatId: f.format_id,
          ext: f.ext,
          resolution: f.resolution,
          fps: f.fps,
          filesize: f.filesize
        })) || []
      };
    } catch (error) {
      console.error('[VideoExtractor] 获取信息失败:', error.message);
      throw new Error(`无法获取视频信息: ${error.message}`);
    }
  }

  /**
   * 提取字幕
   * @param {string} url - 视频URL
   * @param {Object} options - 选项
   * @returns {Promise<Object>} 字幕内容
   */
  async extractSubtitles(url, options = {}) {
    const {
      languages = ['zh-CN', 'zh-TW', 'zh-Hans', 'zh-Hant', 'en'],
      autoGenerated = true
    } = options;
    
    const videoId = this.extractVideoId(url);
    const outputPath = path.join(this.tempDir, `${videoId}.%(ext)s`);
    
    try {
      // 尝试下载人工字幕
      let subtitleContent = await this.downloadSubtitles(url, languages, false, outputPath);
      
      // 如果没有人工字幕且允许自动生成，尝试下载自动字幕
      if (!subtitleContent && autoGenerated) {
        console.log('[VideoExtractor] 未找到人工字幕，尝试自动字幕...');
        subtitleContent = await this.downloadSubtitles(url, languages, true, outputPath);
      }
      
      return subtitleContent || { error: '未找到字幕' };
    } finally {
      // 清理临时文件
      this.cleanup(videoId);
    }
  }

  /**
   * 下载字幕
   */
  async downloadSubtitles(url, languages, autoGenerated, outputPath) {
    const langList = languages.join(',');
    const subFormat = 'srt';
    
    // 构建命令
    let command = `${this.ytDlpPath} --skip-download --write-subs`;
    
    if (autoGenerated) {
      command += ' --write-auto-subs';
    }
    
    command += ` --sub-langs "${langList}" --sub-format ${subFormat}`;
    command += ` -o "${outputPath}" "${url}"`;
    
    try {
      await execAsync(command, { timeout: 120000 });
      
      // 查找下载的字幕文件
      const videoId = path.basename(outputPath, '.%(ext)s');
      const files = fs.readdirSync(this.tempDir);
      const subtitleFile = files.find(f => f.startsWith(videoId) && f.endsWith('.srt'));
      
      if (subtitleFile) {
        const content = fs.readFileSync(
          path.join(this.tempDir, subtitleFile),
          'utf-8'
        );
        
        // 解析字幕
        return {
          type: autoGenerated ? 'auto-generated' : 'manual',
          language: this.detectLanguage(subtitleFile),
          content: this.parseSRT(content),
          rawText: this.extractTextFromSRT(content)
        };
      }
      
      return null;
    } catch (error) {
      // 字幕下载失败不是致命错误
      console.log('[VideoExtractor] 字幕下载失败:', error.message);
      return null;
    }
  }

  /**
   * 提取音频并转录
   * @param {string} url - 视频URL
   * @param {Object} options - 选项
   * @returns {Promise<Object>} 转录结果
   */
  async transcribe(url, options = {}) {
    const {
      language = 'zh',
      model = 'base',
      keepAudio = false
    } = options;
    
    const videoId = this.extractVideoId(url);
    const audioPath = path.join(this.tempDir, `${videoId}.mp3`);
    
    try {
      // 1. 下载音频
      console.log('[VideoExtractor] 下载音频...');
      await this.downloadAudio(url, audioPath);
      
      // 2. 使用Whisper转录
      console.log('[VideoExtractor] 转录音频...');
      const transcript = await this.whisperTranscribe(audioPath, { language, model });
      
      return {
        videoId,
        language,
        model,
        text: transcript.text,
        segments: transcript.segments,
        duration: transcript.duration
      };
    } finally {
      // 清理
      if (!keepAudio) {
        this.cleanup(videoId);
      }
    }
  }

  /**
   * 下载音频
   */
  async downloadAudio(url, outputPath) {
    const command = `${this.ytDlpPath} -x --audio-format mp3 --audio-quality 0 -o "${outputPath}" "${url}"`;
    await execAsync(command, { timeout: 300000 }); // 5分钟超时
  }

  /**
   * Whisper转录
   */
  async whisperTranscribe(audioPath, options = {}) {
    const { language = 'zh', model = 'base' } = options;
    
    // 构建Python命令调用Whisper
    const command = `python3 -c "
import whisper
import json
import sys

model = whisper.load_model('${model}')
result = model.transcribe('${audioPath}', language='${language}', verbose=False)

# 输出JSON
output = {
    'text': result['text'],
    'segments': result['segments'],
    'language': result['language'],
    'duration': result['segments'][-1]['end'] if result['segments'] else 0
}
print(json.dumps(output, ensure_ascii=False))
"`;
    
    const { stdout } = await execAsync(command, { timeout: 600000 }); // 10分钟超时
    return JSON.parse(stdout);
  }

  /**
   * 解析SRT字幕
   */
  parseSRT(content) {
    const entries = [];
    const blocks = content.trim().split(/\n\s*\n/);
    
    for (const block of blocks) {
      const lines = block.trim().split('\n');
      if (lines.length < 3) continue;
      
      const index = parseInt(lines[0]);
      const timeMatch = lines[1].match(/(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})/);
      
      if (timeMatch) {
        entries.push({
          index,
          startTime: timeMatch[1],
          endTime: timeMatch[2],
          text: lines.slice(2).join(' ').trim()
        });
      }
    }
    
    return entries;
  }

  /**
   * 从SRT提取纯文本
   */
  extractTextFromSRT(content) {
    const entries = this.parseSRT(content);
    return entries.map(e => e.text).join(' ');
  }

  /**
   * 检测语言
   */
  detectLanguage(filename) {
    const langMatch = filename.match(/\.([a-zA-Z-]+)\.srt$/);
    return langMatch ? langMatch[1] : 'unknown';
  }

  /**
   * 提取视频ID
   */
  extractVideoId(url) {
    // 简化处理，使用时间戳
    return `video_${Date.now()}`;
  }

  /**
   * 清理临时文件
   */
  cleanup(videoId) {
    try {
      const files = fs.readdirSync(this.tempDir);
      for (const file of files) {
        if (file.startsWith(videoId)) {
          fs.unlinkSync(path.join(this.tempDir, file));
        }
      }
    } catch (e) {
      console.error('[VideoExtractor] 清理失败:', e.message);
    }
  }
}

module.exports = {
  VideoExtractor
};
